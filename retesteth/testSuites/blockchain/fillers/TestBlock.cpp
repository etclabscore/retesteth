#include "TestBlock.h"
using namespace std;

namespace test::blockchainfiller
{
// Raw block RLP, that cann not be generated by retesteth
TestBlock::TestBlock(BYTES const& _rlp, string const& _chainName, FORK const& _chainNet, VALUE const& _number)
  : m_chainName(_chainName), m_doNotExport(false)
{
    m_blockNumber = spVALUE(_number.copy());
    m_chainNet = spFORK(new FORK(_chainNet.asString()));
    m_rawRLP = spBYTES(_rlp.copy());
}

spDataObject TestBlock::asDataObject() const
{
    spDataObject _res;
    DataObject& res = _res.getContent();
    res["chainname"] = m_chainName;
    // res["chainnetwork"] = m_chainNet->asString();
    res["blocknumber"] = m_blockNumber->asDecString();
    if (!m_expectException.empty())
        res["expectException"] = m_expectException;

    // No test objects was registered
    if (!m_block.isEmpty())
    {
        res.atKeyPointer("uncleHeaders") = spDataObject(new DataObject(DataType::Array));
        for (auto const& un : m_block->uncles())
            res["uncleHeaders"].addArrayObject(un->asDataObject());
        res.atKeyPointer("blockHeader") = m_block->header()->asDataObject();
        res.atKeyPointer("transactions") = spDataObject(new DataObject(DataType::Array));
        for (auto const& tr : m_block->transactions())
            res["transactions"].addArrayObject(tr->asDataObject());

        for (auto const& trSequence : m_transactionExecOrder)
        {
            spDataObject _trInfo;
            DataObject& trInfo = _trInfo.getContent();
            BYTES const& b = std::get<0>(trSequence);
            string const& v = std::get<1>(trSequence);
            trInfo["rawBytes"] = b.asString();
            if (v.empty())
                trInfo["valid"] = "true";
            else
            {
                trInfo["valid"] = "false";
                trInfo["exception"] = v;
            }
            res["transactionSequence"].addArrayObject(_trInfo);
        }
    }

    res["rlp"] = m_rawRLP->asString();
    return _res;
}
}  // namespace test::blockchainfiller
